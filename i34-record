#!/usr/bin/perl -w
# Copyright 2009 Abhijit Menon-Sen <ams@toroid.org>
#

use POSIX;
use LWP v5.825;
use Fcntl qw( :flock );
use POE qw( Filter::HTTP::Parser
            Component::Server::TCP
            Component::Client::TCP );

# A typical invocation looks like this:
#
# ./i34-record [-t] from localhost:8888 to foo.example.com:80 in foo
#
# This tells the proxy to accept HTTP connections on localhost:8888,
# forward them to foo.example.com, and maintain a journal of requests
# and responses in a directory named foo.
#
# The "in foo" clause is optional. If omitted, a directory name is
# chosen based on the date and a sequence number (e.g. 20080101-1).
# It is an error to specify the name of an existing directory (thus
# existing transcripts will never be overwritten).
#
# If specified, -t(ransparent) makes i34-record forward the same Host:
# value that the client sends it (which is unlikely to please a server
# that isn't expecting to be transparently proxied). The default is to
# use the server's own hostname:port.
#
# The noise-words "from", "to", and "in" are also optional.

sub help {
    die "Syntax: $0 from <host:port> to <server-url> in <directory>\n";
}

# Where should we listen for connections?
# This argument is assumed to be in "localhost:8889" form.

help() unless @ARGV >= 1;

$transparent = 0;
if ( $ARGV[0] eq "-t" ) {
    $transparent = 1;
    shift @ARGV;
}

shift @ARGV if $ARGV[0] eq "from";
$from = shift @ARGV || help;
($fromhost, $fromport) = split /:/, $from, 2;

# Where should we forward those connections to?
# This argument is also assumed to be in "s.foo.org:8889" form.

help() unless @ARGV >= 1;
shift @ARGV if $ARGV[0] eq "to";
$to = shift @ARGV || help;
($tohost, $toport) = split /:/, $to, 2;
$toport ||= 80;

# Where should we record requests and responses?
# We need a name for a directory we will create, either from the command
# line, or based on today's date.

if ( @ARGV ) {
    shift @ARGV if $ARGV[0] eq "in";
    $recorddir = shift @ARGV || help;
}
else {
    $i = 1;
    $date = strftime( "%Y%m%d", localtime );
    $i++ while -d "$date-$i";
    $recorddir = "$date-$i";
}

die "$0: Won't record to existing directory $recorddir.\n" if -d $recorddir;

# Set up the journal, and the means to manage it.
#
# The directory we create will contain two kinds of files:
#
# 1. A file named journal, which contains one timestamped entry per HTTP
# connection processed by the proxy.
#
# 2. As many numbered files as there are entries in the journal, each
# containing the requests and responses exchanged over a single HTTP
# connection, and named by the process's sequence number.

$connections = 0;

unless ( mkdir $recorddir, 0755 ) {
    die "$0: Can't create directory $recorddir: $!\n";
}

open( JOURNAL, ">", "$recorddir/journal" ) || die "$recorddir/journal: $!\n";
select( (select(JOURNAL), $|=1)[0] );

print "# i34-record from $from to $to in $recorddir\n";
print JOURNAL "# i34-record from $from to $to in $recorddir\n";

# We create a TCP server to accept requests and spawn a TCP client that
# connects to the origin web server, then relay requests and responses
# between the two.

POE::Component::Server::TCP->new(
    Hostname => $fromhost,
    Port => $fromport,

    ClientFilter => POE::Filter::HTTP::Parser->new( type => 'server' ),

    ClientConnected =>
        sub {
            my $heap = $_[HEAP];

            # Make an entry for this new connection in the journal, and
            # open a file to record a transcript of the session.

            my $now = POSIX::strftime( "%Y%m%dT%H%M%S", localtime );
            my $seq = ++$connections;

            print main::JOURNAL "[$now] $seq\n";
            open( RECORD, "+>", "$recorddir/$seq" ) or
                die "Can't open $recorddir/$seq: $!\n";
            select( ( select(RECORD), $|=1 )[0] );

            $heap->{record} = \*RECORD;
            $heap->{connection} = $seq;

            print "Client $seq connected.\n";

            spawn_ua();
        },

    ClientInput =>
        sub {
            my ( $heap, $r ) = @_[ HEAP, ARG0 ];

            # Tell the origin server to send us as plain a response as
            # it can (no compression etc.).

            $r->remove_header( 'TE' );
            $r->header( Accept_Encoding => "" );
            $r->header(
                Host => $transparent ?
                    "$fromhost:$fromport" : "$tohost:$toport"
            );

            $heap->{requests}++;
            write_message( @$heap{qw/record connection requests/}, $r );
            $_[KERNEL]->post(
                $heap->{proxy_ua} => send_request => $r
            );

            print "Client ", $heap->{connection},
                  ", request ", $heap->{requests}, ": ",
                  $r->method, " ", $r->uri->as_string, "\n";
        },

    ClientError => \&client_closed,
    ClientDisconnected => \&client_closed,

    InlineStates => {
        send_response =>
            sub {
                my ( $heap, $r ) = @_[ HEAP, ARG0 ];

                $heap->{responses}++;
                write_message( @$heap{qw/record connection responses/}, $r );
                $heap->{client}->put( $r );

                my $ct = $r->content_type;
                print "Client ", $heap->{connection},
                      ", response ", $heap->{responses}, ": ",
                      $r->status_line, ( $ct ? " ($ct)" : "" ), "\n";
            },

        _child =>
            sub {
                if ( $_[ARG0] eq "create" ) {
                    $_[HEAP]->{proxy_ua} = $_[ARG1]->ID;
                }
            },
    }
);

sub spawn_ua {
    POE::Component::Client::TCP->new(
        RemoteAddress => $tohost,
        RemotePort => $toport,

        Started =>
            sub {
                $_[HEAP]->{proxy_server} = $_[SENDER]->ID;
            },

        Filter => POE::Filter::HTTP::Parser->new( type => 'client' ),

        Connected =>
            sub {
                my $heap = $_[HEAP];

                if ( exists $heap->{request_queue} ) {
                    # If the client sent us any requests before we
                    # connected to the server, send them on now.
                    $heap->{server}->put( @{$heap->{request_queue}} );
                    delete $heap->{request_queue};
                }
            },

        ServerInput =>
            sub {
                my ( $heap, $r ) = @_[ HEAP, ARG0 ];

                # A hackish but fast way to remove comments.
                $r->decode();
                ${$r->content_ref} =~ s/^<!--.*?-->$//gsm;

                $_[KERNEL]->post(
                    $heap->{proxy_server} => send_response => $r
                );
            },

        ServerError => \&server_closed,
        Disconnected => \&server_closed,

        InlineStates => {
            send_request =>
                sub {
                    my ( $heap, $request ) = @_[ HEAP, ARG0 ];

                    if ( $heap->{connected} ) {
                        $heap->{server}->put( $request );
                    } else {
                        push @{ $heap->{request_queue} }, $request;
                    }
                }
        },
    );
}

sub client_closed {
    my $heap = $_[HEAP];

    $_[KERNEL]->post( $heap->{proxy_ua} => "shutdown" );
    print "Client ", $heap->{connection}, " disconnected.\n";
}

sub server_closed {
    $_[KERNEL]->post( $_[HEAP]->{proxy_server} => "shutdown" );
}

POE::Kernel->run();
exit 0;

# This function is responsible for writing HTTP requests and responses
# to a log file in a format that is both human-readable and parseable.
# It duplicates parts of various HTTP::*::as_string() methods.

sub write_message
{
    my ( $record, $connection, $num, $m ) = @_;

    local *RECORD = $record;
    my $now = POSIX::strftime( "%Y%m%dT%H%M%S", localtime );

    my ( $prefix, $start, $type );
    if ( $m->isa( 'HTTP::Request' ) ) {
        $prefix = "C";
        $start = join " ", $m->method, $m->uri->as_string, $m->protocol;
        $type = "Request";
    }
    elsif ( $m->isa( 'HTTP::Response' ) ) {
        $prefix = "S";
        $start = join " ", $m->protocol, $m->status_line;
        $type = "Response";
    }

    # If there is an entity body and it contains only text, we include
    # it inline for convenience. Otherwise we write the contents to a
    # file and include a reference to it.

    my ( @body_lines, $filename );
    if ( length $m->content ) {
        if ( $m->content !~ /[^\r\n\040-\176]/ ) {
            push @body_lines, split /\n/, $m->content;
            if ( $body_lines[-1] =~ /\n$/ ) {
                push @body_lines, "";
            }
        }
        else {
            $filename = $connection .".". $prefix .".". $num;
            open( F, ">", "$recorddir/$filename" ) or
                die "$recorddir/filename: $!\n";
            syswrite( F, $m->content );
            close( F );
        }
    }

    print RECORD "[$now] $type #$num\n";
    print RECORD
        map { "$prefix: $_\n" }
            $start, header_lines( $m ), "", @body_lines;
    if ( $filename ) {
        print RECORD "F: [$filename]\n";
    }
    print RECORD "\n";
}

sub header_lines {
    my ( $m ) = @_;

    my @headers;
    $m->headers->scan(sub {
        my ( $field, $value ) = @_;

        $field =~ s/^://;
        if ( $value =~ /\n/ ) {
            $value =~ s/\s+$//;
            $value =~ s/\n\n+/\n/g;
            $value =~ s/\n([^\040\t])/\n $1/g;
        }

        my @values = split /\n/, $value;
        if ( $field ne "Via" &&
             $field ne "X-Forwarded-For" )
        {
            my $value = shift @values;
            push @headers, "$field: $value";
            push @headers, @values;
        }
    });

    return @headers;
}

=pod

=head1 NAME

i34-record - A transparent web proxy that records requests and responses.

=head1 SYNOPSIS

i34-record from 127.0.0.1:8889 to www.example.org:80 in a

=head1 DESCRIPTION

The command shown above will start i34-record, which will accept HTTP
requests on C<127.0.0.1:8889> and relay them to the origin server at
C<www.example.org:80> and store a complete session transcript in the
directory named F<a>.

Later, C<i34-record> can be restarted (with a different log directory)
and C<i34-replay> can use the transcript in F<a> to recreate requests
and resend them through the proxy server. Then the two transcripts can
be compared using C<i34-diff>.

The local and remote servers must be specified in "host:port" format
(both hostnames and IP addresses are fine). The default port for the
origin server is 80. There is no default for the local server.

The directory name is optional. If not specified, one will be generated
based on the date and a sequence number. (That is, if it is 2009-03-20
and a directory named 20090320-1 exists, then 20090320-2 will be used.)
It is an error to specify a directory that already exists; this is to
make it harder to inadvertently overwrite old session transcripts.

The words "from", "to", and "in" are also optional.

The transcript directory contains a file named F<journal> which lists
all the client connections and, for each connection, a numbered file
that stores the requests and responses sent and received over that
connection. Non-text message bodies are stored separately in files
of their own.

These transcripts are in a human-readable format, where lines from the
client are prefixed with "C: ", and lines from the server with "S: ".

See L<http://toroid.org/inspector34> for more.

=head1 AUTHOR

Abhijit Menon-Sen <ams@toroid.org>

=head1 COPYRIGHT

Copyright 2009 Abhijit Menon-Sen <ams@toroid.org>

This program may be used, modified, or redistributed freely, provided
that modified versions are clearly identified as being different from
the original, and that copyright notices and acknowledgements are not
removed from the code or the accompanying documentation.

This program is provided without any warranty, express or implied. In
no event shall the author or contributors to this program be liable
for any damages arising from its use.

=head1 SEE ALSO

i34-replay, i34-diff
