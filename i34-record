#!/usr/bin/perl -w
# Copyright 2009 Abhijit Menon-Sen <ams@toroid.org>
#

use POSIX;
use Fcntl qw( :flock );
use POE qw( Filter::HTTP::Parser
            Component::Server::TCP
            Component::Client::TCP );

# A typical invocation looks like this:
#
# ./i34-record from localhost:8888 to foo.example.com:80 in foo
#
# This tells the proxy to accept HTTP connections on localhost:8888,
# forward them to foo.example.com, and maintain a journal of requests
# and responses in a directory named x.
#
# The "in foo" clause is optional. If omitted, a directory name is
# chosen based on the date and a sequence number (e.g. 20080101-1).
# It is an error to specify the name of an existing directory (thus
# existing transcripts will never be overwritten).
#
# The noise-words "from", "to", and "in" are also optional.

sub help {
    die "Syntax: $0 from <host:port> to <server-url> in <directory>\n";
}

# Where should we listen for connections?
# This argument is assumed to be in "localhost:8889" form.

help() unless @ARGV >= 1;
shift @ARGV if $ARGV[0] eq "from";
$from = shift @ARGV || help;
($fromhost, $fromport) = split /:/, $from, 2;

# Where should we forward those connections to?
# This argument is also assumed to be in "s.foo.org:8889" form.

help() unless @ARGV >= 1;
shift @ARGV if $ARGV[0] eq "to";
$to = shift @ARGV || help;
($tohost, $toport) = split /:/, $to, 2;
$toport ||= 80;

# Where should we record requests and responses?
# We need a name for a directory we will create, either from the command
# line, or based on today's date.

if ( @ARGV ) {
    shift @ARGV if $ARGV[0] eq "in";
    $recorddir = shift @ARGV || help;
}
else {
    $i = 1;
    $date = strftime( "%Y%m%d", localtime );
    $i++ while -d "$date-$i";
    $recorddir = "$date-$i";
}

die "$0: Won't record to existing directory $recorddir.\n" if -d $recorddir;

# Set up the journal, and the means to manage it.
#
# The directory we create will contain two kinds of files:
#
# 1. A file named journal, which contains one timestamped entry per HTTP
# connection processed by the proxy.
#
# 2. As many numbered files as there are entries in the journal, each
# containing the requests and responses exchanged over a single HTTP
# connection, and named by the process's sequence number.

$connections = 0;

unless ( mkdir $recorddir, 0755 ) {
    die "$0: Can't create directory $recorddir: $!\n";
}

open( JOURNAL, ">", "$recorddir/journal" ) || die "$recorddir/journal: $!\n";
select( (select(JOURNAL), $|=1)[0] );

print JOURNAL "# i34-record from $from to $to in $recorddir\n";

# We create a TCP server to accept requests and spawn a TCP client that
# connects to the origin web server, then relay requests and responses
# between the two.

POE::Component::Server::TCP->new(
    Hostname => $fromhost,
    Port => $fromport,

    ClientFilter => POE::Filter::HTTP::Parser->new( type => 'server' ),

    ClientConnected =>
        sub {
            my $heap = $_[HEAP];

            # Make an entry for this new connection in the journal, and
            # open a file to record a transcript of the session.

            my $now = POSIX::strftime( "%Y%m%dT%H%M%S", localtime );
            my $seq = ++$connections;

            print main::JOURNAL "[$now] $seq\n";
            open( RECORD, "+>", "$recorddir/$seq" ) or
                die "Can't open $recorddir/$seq: $!\n";
            select( ( select(RECORD), $|=1 )[0] );

            $heap->{record} = \*RECORD;
            $heap->{connection} = $seq;

            spawn_ua();
        },

    ClientInput =>
        sub {
            my ( $heap, $r ) = @_[ HEAP, ARG0 ];

            # Tell the origin server to send us as plain a response as
            # it can (no compression etc.).

            $r->remove_header( 'TE' );
            $r->header( Accept_Encoding => "" );
            $r->header( Host => "$fromhost:$fromport" );

            $heap->{requests}++;
            write_message( @$heap{record, connection, requests}, $r );
            $_[KERNEL]->post(
                $heap->{proxy_ua} => send_request => $r
            );
        },

    ClientError => \&client_closed,
    ClientDisconnected => \&client_closed,

    InlineStates => {
        send_response =>
            sub {
                my ( $heap, $r ) = @_[ HEAP, ARG0 ];

                $heap->{responses}++;
                write_message( @$heap{record, connection, responses}, $r );
                $heap->{client}->put( $r );
            },

        _child =>
            sub {
                if ( $_[ARG0] eq "create" ) {
                    $_[HEAP]->{proxy_ua} = $_[ARG1]->ID;
                }
            },
    }
);

sub spawn_ua {
    POE::Component::Client::TCP->new(
        RemoteAddress => $tohost,
        RemotePort => $toport,

        Started =>
            sub {
                $_[HEAP]->{proxy_server} = $_[SENDER]->ID;
            },

        Filter => POE::Filter::HTTP::Parser->new( type => 'client' ),

        Connected =>
            sub {
                my $heap = $_[HEAP];

                if ( exists $heap->{request_queue} ) {
                    # If the client sent us any requests before we
                    # connected to the server, send them on now.
                    $heap->{server}->put( @{$heap->{request_queue}} );
                    delete $heap->{request_queue};
                }
            },

        ServerInput =>
            sub {
                my ( $heap, $r ) = @_[ HEAP, ARG0 ];

                # A hackish but fast way to remove comments.
                $r->decode();
                ${$r->content_ref} =~ s/^<!--.*?-->$//gsm;

                $_[KERNEL]->post(
                    $heap->{proxy_server} => send_response => $r
                );
            },

        ServerError => \&server_closed,
        Disconnected => \&server_closed,

        InlineStates => {
            send_request =>
                sub {
                    my ( $heap, $request ) = @_[ HEAP, ARG0 ];

                    if ( $heap->{connected} ) {
                        $heap->{server}->put( $request );
                    } else {
                        push @{ $heap->{request_queue} }, $request;
                    }
                }
        },
    );
}

sub client_closed {
    $_[KERNEL]->post( $_[HEAP]->{proxy_ua} => "shutdown" );
}

sub server_closed {
    $_[KERNEL]->post( $_[HEAP]->{proxy_server} => "shutdown" );
}

POE::Kernel->run();
exit 0;

# This function is responsible for writing HTTP requests and responses
# to a log file in a format that is both human-readable and parseable.
# It duplicates parts of various HTTP::*::as_string() methods.

sub write_message
{
    my ( $record, $connection, $num, $m ) = @_;

    local *RECORD = $record;
    my $now = POSIX::strftime( "%Y%m%dT%H%M%S", localtime );

    my ( $prefix, $start, $type );
    if ( $m->isa( 'HTTP::Request' ) ) {
        $prefix = "C";
        $start = join " ", $m->method, $m->uri->as_string, $m->protocol;
        $type = "Request";
    }
    elsif ( $m->isa( 'HTTP::Response' ) ) {
        $prefix = "S";
        $start = join " ", $m->protocol, $m->status_line;
        $type = "Response";
    }

    # If there is an entity body and it contains only text, we include
    # it inline for convenience. Otherwise we write the contents to a
    # file and include a reference to it.

    my ( @body_lines, $filename );
    if ( length $m->content ) {
        if ( $m->content !~ /[^\r\n\040-\176]/ ) {
            push @body_lines, split /\n/, $m->content;
            if ( $body_lines[-1] =~ /\n$/ ) {
                push @body_lines, "";
            }
        }
        else {
            $filename = $connection .".". $prefix .".". $num;
            open( F, ">", "$recorddir/$filename" ) or
                die "$recorddir/filename: $!\n";
            syswrite( F, $m->content );
            close( F );
        }
    }

    print RECORD "[$now] $type #$num\n";
    print RECORD
        map { "$prefix: $_\n" }
            $start, header_lines( $m ), "", @body_lines;
    if ( $filename ) {
        print RECORD "F: [$filename]\n";
    }
    print RECORD "\n";
}

sub header_lines {
    my ( $m ) = @_;

    my @headers;
    $m->headers->scan(sub {
        my ( $field, $value ) = @_;

        $field =~ s/^://;
        if ( $value =~ /\n/ ) {
            $value =~ s/\s+$//;
            $value =~ s/\n\n+/\n/g;
            $value =~ s/\n([^\040\t])/\n $1/g;
        }

        my @values = split /\n/, $value;
        if ( $field ne "Via" &&
             $field ne "X-Forwarded-For" )
        {
            my $value = shift @values;
            push @headers, "$field: $value";
            push @headers, @values;
        }
    });

    return @headers;
}
